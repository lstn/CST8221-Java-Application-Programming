/**
 * Filename: ClientView.java
 * Author: Lucas Estienne, 040 819 959
 * Course: CST8221 - JAP, Lab Section: 302
 * Assignment: 2
 * Date: 12/8/2016
 * Professor: Svillen Ranev
 * Purpose: Responsible for building the client GUI and handling the client socket connection.
 * Class list: ClientView, SwingWorkerRunnable
 */

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;

/**
 * This class is responsible for launching the Client application and handling the client thread & connections.
 * 
 * @author Lucas Estienne
 * @version 1.0
 * @see javax.swing.JFrame
 * @since 1.8.0_112
*/
public class ClientView extends javax.swing.JFrame {
    /**
     * Default timeout, in milliseconds, for a socket connection attempt. Value: {@value}
     */
    private static final int DEFAULT_CONNECT_TIMEOUT = 4500; // milliseconds

    /**
     * the Socket object for our client
     */
    private Socket clientSocket;
    /**
     * the output stream for our client
     */
    private ObjectOutputStream sockOutput;
    /**
     * the input stream for our client
     */
    private ObjectInputStream sockInput;
    /**
     * the Thread which manages the client connection
     */
    private Thread clientListener;
    /**
     * whether or not the thread should currently be running
     */
    private boolean isThreadRunning = false;
    
    /**
     * Default constructor for the ClientView class.
     * Builds a Client GUI and spawns a Thread to manage the client connections.
    */
    public ClientView() {
        // initialize the client view
        initComponents();
        this.setSize(600+7, 550+7); 
        this.hostLabel.setLabelFor(this.hostTextField);
        this.portLabel.setLabelFor(this.portComboBox);
        
        // initialize our Thread
        clientListener = new Thread(new SwingWorkerRunnable());
        
        // add listener to window close so that we can close our streams, our connection and kill our thread
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent evt) {
                isThreadRunning = false;
                tryCloseIOStreams();
                if (clientSocket != null && clientSocket.isConnected()){
                    try{
                        clientSocket.close();
                    } catch (IOException e) {
                        System.err.println("IO Exception on window close");
                        e.printStackTrace();
                    }
                }
            }
        });
        
        // start thread
        isThreadRunning = true;
        clientListener.start();
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        connectionPanel = new javax.swing.JPanel();
        hostLabel = new javax.swing.JLabel();
        portLabel = new javax.swing.JLabel();
        hostTextField = new javax.swing.JTextField();
        portComboBox = new javax.swing.JComboBox<>();
        connectBtn = new javax.swing.JButton();
        clientReqPanel = new javax.swing.JPanel();
        reqTextField = new javax.swing.JTextField();
        sendBtn = new javax.swing.JButton();
        terminalPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        terminalTextArea = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Lucas Estienne's Client");
        setBackground(new java.awt.Color(240, 240, 240));
        setMinimumSize(new java.awt.Dimension(600, 550));
        setPreferredSize(new java.awt.Dimension(600, 550));
        setSize(new java.awt.Dimension(600, 550));

        connectionPanel.setBackground(new java.awt.Color(240, 240, 240));
        connectionPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(255, 0, 51), 10), "SET CONNECTION", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 1, 12), new java.awt.Color(102, 102, 102))); // NOI18N
        connectionPanel.setForeground(new java.awt.Color(153, 153, 153));
        connectionPanel.setName("Connection panel"); // NOI18N

        hostLabel.setDisplayedMnemonic('H');
        hostLabel.setForeground(new java.awt.Color(0, 0, 0));
        hostLabel.setText("Host:");
        hostLabel.setMaximumSize(new java.awt.Dimension(40, 40));
        hostLabel.setMinimumSize(new java.awt.Dimension(40, 40));
        hostLabel.setPreferredSize(new java.awt.Dimension(40, 40));

        portLabel.setDisplayedMnemonic('P');
        portLabel.setForeground(new java.awt.Color(0, 0, 0));
        portLabel.setText("Port:");
        portLabel.setMaximumSize(new java.awt.Dimension(40, 40));
        portLabel.setMinimumSize(new java.awt.Dimension(40, 40));
        portLabel.setPreferredSize(new java.awt.Dimension(40, 40));

        hostTextField.setBackground(new java.awt.Color(255, 255, 255));
        hostTextField.setText("localhost");

        portComboBox.setBackground(new java.awt.Color(255, 255, 255));
        portComboBox.setEditable(true);
        portComboBox.setForeground(new java.awt.Color(204, 204, 204));
        portComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "", "8088", "65000", "65535" }));
        portComboBox.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        portComboBox.setMaximumSize(new java.awt.Dimension(60, 26));
        portComboBox.setMinimumSize(new java.awt.Dimension(60, 26));
        portComboBox.setPreferredSize(new java.awt.Dimension(60, 26));

        connectBtn.setBackground(new java.awt.Color(255, 0, 51));
        connectBtn.setForeground(new java.awt.Color(0, 0, 0));
        connectBtn.setMnemonic('c');
        connectBtn.setText("Connect");
        connectBtn.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        connectBtn.setMaximumSize(new java.awt.Dimension(60, 26));
        connectBtn.setMinimumSize(new java.awt.Dimension(60, 26));
        connectBtn.setPreferredSize(new java.awt.Dimension(60, 26));
        connectBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                connectBtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout connectionPanelLayout = new javax.swing.GroupLayout(connectionPanel);
        connectionPanel.setLayout(connectionPanelLayout);
        connectionPanelLayout.setHorizontalGroup(
            connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(connectionPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(hostLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(portLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(connectionPanelLayout.createSequentialGroup()
                        .addComponent(portComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(connectBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(hostTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 480, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(39, Short.MAX_VALUE))
        );
        connectionPanelLayout.setVerticalGroup(
            connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(connectionPanelLayout.createSequentialGroup()
                .addGroup(connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(hostLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(hostTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(portLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(portComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(connectBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        clientReqPanel.setBackground(new java.awt.Color(240, 240, 240));
        clientReqPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 10), "CLIENT REQUEST", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 1, 12), new java.awt.Color(102, 102, 102))); // NOI18N
        clientReqPanel.setForeground(new java.awt.Color(153, 153, 153));

        reqTextField.setBackground(new java.awt.Color(255, 255, 255));
        reqTextField.setText("Type a server request line");

        sendBtn.setBackground(new java.awt.Color(204, 204, 204));
        sendBtn.setMnemonic('s');
        sendBtn.setText("Send");
        sendBtn.setToolTipText("");
        sendBtn.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        sendBtn.setEnabled(false);
        sendBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendBtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout clientReqPanelLayout = new javax.swing.GroupLayout(clientReqPanel);
        clientReqPanel.setLayout(clientReqPanelLayout);
        clientReqPanelLayout.setHorizontalGroup(
            clientReqPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(clientReqPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(reqTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 473, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(sendBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        clientReqPanelLayout.setVerticalGroup(
            clientReqPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(clientReqPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(clientReqPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(reqTextField)
                    .addComponent(sendBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        terminalPanel.setBackground(new java.awt.Color(240, 240, 240));
        terminalPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(51, 51, 255), 10), "TERMINAL", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 1, 12), new java.awt.Color(102, 102, 102))); // NOI18N

        jScrollPane1.setBackground(new java.awt.Color(255, 255, 255));
        jScrollPane1.setEnabled(false);

        terminalTextArea.setEditable(false);
        terminalTextArea.setBackground(new java.awt.Color(255, 255, 255));
        terminalTextArea.setColumns(20);
        terminalTextArea.setRows(5);
        jScrollPane1.setViewportView(terminalTextArea);

        javax.swing.GroupLayout terminalPanelLayout = new javax.swing.GroupLayout(terminalPanel);
        terminalPanel.setLayout(terminalPanelLayout);
        terminalPanelLayout.setHorizontalGroup(
            terminalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
        );
        terminalPanelLayout.setVerticalGroup(
            terminalPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 273, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(terminalPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(clientReqPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(connectionPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(connectionPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(clientReqPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(terminalPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(79, 79, 79))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * This method sends commands to the server every time the `send` button is interacted with.
     * 
     * @param evt ActionEvent the event that triggered this method
    */
    private void sendBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendBtnActionPerformed
        if(clientSocket != null && clientSocket.isConnected() && openIOStreams()){
            try{
                sockOutput.writeObject(reqTextField.getText());
            } catch (IOException e){
                System.err.println("Error trying to send command to server");
                e.printStackTrace();
            }
        }
    }//GEN-LAST:event_sendBtnActionPerformed

    /**
     * This method attempts to connect to a server using user-input fields whenever the `connect` button is pressed.
     * If the connection is successful, the `connect` button is disabled and colored blue, while the `send` button becomes enabled.
     * Otherwise, the `connect` button becomes enabled again and `send` stays disabled.
     * 
     * @param evt ActionEvent the event that triggered this method
    */
    private void connectBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectBtnActionPerformed
        // disable connect button as well as send button
        connectBtn.setBackground(Color.BLUE);
        connectBtn.setEnabled(false);
        sendBtn.setEnabled(false);
        
        try{
            clientSocket = new Socket();
            clientSocket.connect(new InetSocketAddress(
                    hostTextField.getText(), 
                    Integer.parseInt(portComboBox.getSelectedItem().toString()) // parse the combo box
                    ), DEFAULT_CONNECT_TIMEOUT); // timeout if connection can't be established
            if(clientSocket.isConnected()){
                terminalTextArea.append("Connected to " + clientSocket.toString() + "\n");
            }
            
        } catch(UnknownHostException e) { // host input doesn't exist, i.e. "localhost1111"
            clientMsgToTerminal("ERROR: Unknown Host");
            
            System.err.println("Unknown Host Exception caught");
            e.printStackTrace();
        } catch(ConnectException e) { // port is busy or server is not running
            clientMsgToTerminal("ERROR: Connection refused: server is not available. Check port or restart server.");
            
            System.err.println("Connect Exception caught");
            e.printStackTrace();
        } catch(IOException e) {
            System.err.println("IO Exception while trying to connect");
            e.printStackTrace();
        } finally {
            if(!clientSocket.isConnected()){
                // re-enable connect button, keep send button disabled
                connectBtn.setBackground(Color.RED);
                connectBtn.setEnabled(true);
                sendBtn.setEnabled(false);
            } else {
                // keep connect button disabled, enable send button
                sendBtn.setEnabled(true);
            }
        }
    }//GEN-LAST:event_connectBtnActionPerformed

    /**
     * This method logs a message in the terminal text area and marks it as being from the client.
     * 
     * @param message String the message to be passed to the terminal
    */
    private void clientMsgToTerminal(String message){
        terminalTextArea.append("CLIENT>" + message + "\n");
    }
    
    /**
     * This method logs a message in the terminal text area and marks it as being from the server.
     * 
     * @param message String the message to be passed to the terminal
    */
    private void serverMsgToTerminal(String message){
        terminalTextArea.append("SERVER>" + message + "\n");
    }
    
    /**
     * This method attempts to open an ObjectOutputStream & ObjectInputStream to act as
     * input/output for our client.
     * 
     * @return boolean true if successful false if not
    */
    private boolean openIOStreams(){
        if(clientSocket == null || clientSocket.isClosed()){ // fail if clientsocket isn't connected
            return false;
        }
        if(sockOutput != null && sockInput != null){ // if output and input aren't null then return success
            return true;
        }
        
        try{
            // initialize input and output
            sockOutput = new ObjectOutputStream(clientSocket.getOutputStream());
            sockInput = new ObjectInputStream(clientSocket.getInputStream());
            return true; // success
        } catch(IOException e){
            System.err.println("Error opening input or output streams for connection");
            e.printStackTrace();
            //closeSocket();
        }
        return false;
    }
    
    /**
     * This method tries to close and null the input and output streams if they are not null.
    */
    private void tryCloseIOStreams(){
        if (sockOutput != null && sockInput != null){
            try{
                sockInput.close();
                sockOutput.close();
            } catch(IOException e) {
                System.err.println("IOException while trying to close streams");
                e.printStackTrace();
            } finally {
                sockInput = null;
                sockOutput = null;
            }
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel clientReqPanel;
    private javax.swing.JButton connectBtn;
    private javax.swing.JPanel connectionPanel;
    private javax.swing.JLabel hostLabel;
    private javax.swing.JTextField hostTextField;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JComboBox<String> portComboBox;
    private javax.swing.JLabel portLabel;
    private javax.swing.JTextField reqTextField;
    private javax.swing.JButton sendBtn;
    private javax.swing.JPanel terminalPanel;
    private javax.swing.JTextArea terminalTextArea;
    // End of variables declaration//GEN-END:variables

    /**
    * This class implements Runnable and acts as a listener for receiving messages from the server.
    * 
    * @author Lucas Estienne
    * @version 1.0
    * @see Runnable
    * @since 1.8.0_112
    */
    private class SwingWorkerRunnable implements Runnable{
        
        /**
        * Overrides Runnable.run and begins running in a loop listening for & handling server messages
        * until we kill the loop by flipping isThreadRunning to false.
        */
        @Override
        public void run() {
            try{
                while (isThreadRunning){
                    if(clientSocket == null || sockInput == null || sockOutput == null || clientSocket.isClosed()){
                        Thread.sleep(350); // socket or streams aren't fully initialized yet, sleep for 350 ms
                    } else {
                        String incoming = (String) sockInput.readObject(); // attempt to read incoming message from server
                        
                        if(incoming.length() == 3 && incoming.substring(0, 3).equals("cls")){ // command to clear terminal
                            EventQueue.invokeLater(() -> {terminalTextArea.setText("");});  // lambda runnable.run() to be invoked in event dispatch thread.
                            
                        } else if (incoming.startsWith("Available Services:") 
                                || incoming.startsWith("ERROR:") || incoming.startsWith("ECHO: ")
                                || incoming.startsWith("TIME: ") || incoming.startsWith("DATE: ")
                                ){
                            
                            EventQueue.invokeLater(() -> {serverMsgToTerminal(incoming);}); // lambda runnable.run() to be invoked in event dispatch thread.
                            
                        } else if (incoming.startsWith("Connection closed")){ // server closed socket, so we close ours
                            EventQueue.invokeLater(() -> { // lambda runnable.run() to be invoked in event dispatch thread.
                                serverMsgToTerminal(incoming);
                                try {
                                    tryCloseIOStreams(); // attempt to close IO streams
                                    clientSocket.close(); // attempt to close socket 
                                } catch (IOException e) {
                                    System.err.println("IO Exception while closing client socket");
                                    e.printStackTrace();
                                } finally {
                                    clientMsgToTerminal("Connection closed.");
                                    
                                    // enables connect button again, sets it to red, and disables send button.
                                    connectBtn.setBackground(Color.RED);
                                    connectBtn.setEnabled(true);
                                    sendBtn.setEnabled(false);
                                }
                            }); 
                        } else {
                            EventQueue.invokeLater(() -> {serverMsgToTerminal("ERROR: Unrecognized command.");}); // lambda runnable.run() to be invoked in event dispatch thread.
                        }
                        
                        Thread.sleep(1);
                    }
                }
            } catch (InterruptedException e) {
                System.err.println("Socket interrupted during sleep wait");
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                System.err.println("Could not find class");
                e.printStackTrace();
            } catch (IOException e){
                System.err.println("IO Exception caught in thread");
                e.printStackTrace();
            } 
        }
        
    }
}
